<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML><HEAD><meta http-equiv="Content-Type"
content="text/html;charset=utf-8">
<link REL="stylesheet" TYPE="text/css"
href="../fsl.css"><TITLE>FSL</TITLE></HEAD>
<BODY><IFRAME width="100%" scrolling="no" frameborder="0" src="fdt_top.html">Broken</IFRAME>

<a name="thresh"></a>
<h3>proj_thresh</h3>
<b>proj_thresh</b> is a command line utility that provides an alternative way of
expressing connection probability in connectivity-based segmentation.  It is
run on the output of <a href="fdt_probtrackx.html"> <b>probtrackx</b></a> when <b>classification targets</b> are used.

<p>The output of <b>Connectivity-based seed classification</b> is a single volume for
each target mask, named <b>seeds_to_{target}</b> where {target} is replaced
by the file name of the relevant target mask. In these output images, the
value of each voxel within the seed mask is the number of samples seeded
from that voxel reaching the target mask. 
<br><b>proj_thresh</b> is run as follows:
<p><b>proj_thresh list_of_volumes threshold</b></p>
Where the list of volumes is the outputs of <b>Connectivity-based seed
classification</b> (i.e., files named seeds_to_target1 etc etc) and threshold is expressed as a number of samples
<br>For each voxel in the seeds mask that has a value above threshold for at
least one target mask, <b>proj_thresh</b> calculates the number of samples reaching each target mask
as a proportion of the total number of samples reaching any target mask.  The
output of <b>proj_thresh</b> is a single volume for each target mask.  

<hr>

<a name="biggest"></a>
<h3>find_the_biggest</h3>
<b>find_the_biggest</b> is a command line utility that performs hard
segmentation of a seed region on the basis of outputs of <a
href="fdt_probtrackx.html"><b>probtrackx</b></a> when <b>classification targets</b> are being used.

<p>The output of <b>Connectivity-based seed classification</b> is a single volume for
each target mask, named <b>seeds_to_{target}</b> where {target} is replaced
by the file name of the relevant target mask. In these output images, the
value of each voxel within the seed mask is the number of samples seeded
from that voxel reaching the target mask. <b>find_the_biggest</b> classifies
seed voxels according to the target mask with which they show the highest
probability of connection. It is run as follows:
<p><b>find_the_biggest list_of_volumes outputname</b>
Where the list of volumes is the outputs of <b>Connectivity-based seed
classification</b> (i.e., files named seeds_to_target1 etc etc).

<p>The example below uses <a href="fdt_probtrackx.html"><b>probtrackx</b></a> and find_the_biggest to perform hard segmentation
of the thalamus on the basis of its connections to cortex.


<p><IMG height=300 SRC="fdt_images/fdt_seeds2targets_thal.gif"
ALT="connectivity-based classification of thalamus">

<hr>

<a name="vecreg"></a>
<h3>vecreg - Registration of vector images</h3>

<p>

<IMG ALIGN=RIGHT height=200 SRC="fdt_images/fdt_vecreg.gif"
ALT="vecreg applied to V1">  
After running dtifit or bedpostx, it is often useful to register vector data to another space. For example, one might want to represent V1 for different subjects in standard space. <b>vecreg</b> is a command line tool that allows to perform such registration.<br><br>
Vector images cannot be registered by simply applying a transformation (as calculated by, say, <a href="http://www.fmrib.ox.ac.uk/fsl/flirt/index.html">FLIRT</a>) to every voxel's coordinates. The corresponding vectors have to be reoriented accordingly (see D. Alexander 2001, IEEE-TMI 20:1131-39). <b>vecreg</b> performs this operation for you.
The image on the right shows the effect of applying vecreg (right) to the V1 image on the left, compared to simply applying voxelwise transformation (e.g. using applyxfm4D) to the vectors (centre).
<br><br>
<b> Important: </b> vecreg does not calculate a transformation, but simply applies a given transformation to the input vector field. vecreg can apply a linear transformation calculated with FLIRT, or a non-linear transformation calculated by FNIRT.

<p>

types of input that may be used for vecreg<br>
from <a href="fdt_dtifit.html"><b>dtifit</b></a>: V1,V2,V3,tensor<br>
from <a href="fdt_bedpostx.html"><b>bedpostx</b></a>: dyads1, dyads2, etc. <br>

<p>

<h3>Command-line utility</h3>
<b>using a flirt matrix</b><br>
vecreg -i input_vector -o output_vector -r reference_image -t flirt_transform.mat<br>
<b>using a warpfield</b><br>
vecreg -i input_vector -o output_vector -r reference_image -w warp_field<br>

<br><b>more options</b>
<pre> 
vecreg -i &lt;input4D&gt; -o &lt;output4D&gt; -r &lt;refvol&gt; [-t &lt;transform&gt;]


Compulsory arguments (You MUST set one or more of):
	-i,--input	filename for input vector or tensor field
	-o,--output	filename for output registered vector or tensor field
	-r,--ref	filename for reference (target) volume

Optional arguments (You may optionally specify one or more of):
	-v,--verbose	switch on diagnostic messages
	-h,--help	display this message
	-t,--affine	filename for affine transformation matrix
	-w,--warpfield	filename for 4D warp field for nonlinear registration
	--rotmat	filename for secondary affine matrix 
			if set, this will be used for the rotation of the vector/tensor field 
	--rotwarp	filename for secondary warp field 
			if set, this will be used for the rotation of the vector/tensor field 
	--interp	interpolation method : nearestneighbour, trilinear (default), sinc or spline
	-m,--mask	brain mask in input space
	--refmask	brain mask in output space (useful for speed up of nonlinear reg)

</pre>
 

<hr>

<a name="qboot"></a>
<h3>qboot - Estimation of fibre orientations using q-ball ODFs and residual bootstrap</h3>

<p>

<IMG ALIGN=RIGHT height=300 SRC="fdt_images/qboot.gif"
ALT="Different types of ODFs that can be inferred">
<b>qboot</b> is a command line tool that allows estimation of diffusion ODFs and fibre orientations from them. Its output can be used as an input for probtrackX in order to perform probabilistic tractography.<br><br>

ODF estimation is performed using a real spherical harmonics basis. Fibre orientations are estimated as the local maxima of the ODFs. Both deterministic and probabilistic estimation can be performed. For the latter, residual bootstrap is performed to infer on the ODF shape and obtain a distribution of fibre orientations. For more details on the implementation see (S.N. Sotiropoulos, I. Aganj, S. Jbabdi, G. Sapiro, C. Lenglet and T.E. Behrens, "Inference on Constant Solid Angle Orientation Distribution Functions from Diffusion-Weighted MRI", OHBM, 2011).<br><br> 

<b>qboot</b> allows reconstruction of q-ball ODFs (Tuch, MRM, 2004), CSA ODFs (Aganj et al, MRM, 2010) and variants of them, obtained via Laplacian sharpening and Laplace-Beltrami regularization (Descoteaux et al, MRM, 2007). Both spherical harmonic coefficients of the reconstructed ODFs and fibre orientation estimates may be returned as ouput. 
<br><br>

<p>

<b>Input files for qboot </b>: Similar to dtifit and bedpostx, qboot needs a 4D data file, a binary mask_file, a bvecs and a bvals file.

<p>

<b>Command-line utility</b>
<pre>
qboot -k data_file -m nodif_brain_mask -r bvecs -b bvals
</pre>

<br><b>more options</b>
<pre>
Compulsory arguments (You MUST set one or more of):
	-k,--data	Data file
	-m,--mask	Mask file
	-r,--bvecs	b vectors file
	-b,--bvals	b values file

Optional arguments (You may optionally specify one or more of):
	--ld,--logdir	Output directory (default is logdir)
	--forcedir	Use the actual directory name given - i.e. don't add + to make a new directory
	--q		File provided with multi-shell data. Indicates the number of directions for each shell
	--model		Which model to use. 1=Tuch's ODFs, 2=CSA ODFs (default), 3=multi-shell CSA ODFs
	--lmax		Maximum spherical harmonic order employed (must be even, default=4)
	--npeaks	Maximum number of ODF peaks to be detected (default 2)
	--thr		Minimum threshold for a local maxima to be considered an ODF peak.
                        Expressed as a fraction of the maximum ODF value (default 0.4)
	--pf		Which peak finder to use. 1=Discrete, 2=Semi-continuous (can be only used with lmax=4) (default=1)
	--ns,--nsamples	Number of bootstrap samples (default is 50)
	--lambda	Laplace-Beltrami regularization parameter (default is 0)
	--delta		Signal attenuation regularization parameter for model=2 (default is 0.01)
	--alpha		Laplacian sharpening parameter for model=1 (default is 0, should be smaller than 1)
	--seed		Seed for pseudo-random number generator
	--savecoeff	Save the ODF coefficients instead of the peaks. 
	--savemeancoeff	Save the mean ODF coefficients across all samples
	-V,--verbose	Switch on diagnostic messages

</pre>

<b>Possible Outputs of qboot</b>
<p><ul>
<li>qboot will by default return distributions of ODF peaks. Setting <i> --ns=1 </i>, will perform <b> deterministic </b> estimation of
the ODFs and their peaks.</li>
<li>If <i>--savecoeff </i> is set, then only samples of the ODF coefficients will be saved, without any peaks.</li>
<li>If <i>--savecoeff --savemeancoeff </i> are set, then only the mean ODF coefficients (across the samples) will be saved for each voxel and
again no peaks.</li>
<li>If <i> --savemeancoeff </i> is set, then the mean ODF coefficients (across the samples) will be saved for each voxel, along with the
samples of the ODF peaks.</li>
<li>If none of the above is set, samples of the ODF peaks are saved.</li>
</ul>
<p> <p>
<b>Multi-shell data assumptions</b>
<p>
The current implementation of qboot can estimate multi-shell ODFs, assuming the following for the data:
<ul><li>Three-shell data are assumed. The bvalues should form an arithmetic progression, e.g. 1000, 2000, 3000 or 2000, 4000, 6000.</li>  
<li>It is assumed that all data from each shell are grouped together and shells are one after the other in data, bvecs and bvals. So, if
for example 3 directions are available for 3 shells these should appear as: dir1_shell1, dir2_shell1, dir3_shell1, dir1_shell2,dir2_shell2, dir3_shell2,      dir1_shell3,dir2_shell3, dir3_shell3.</li>
<li>There is no assumption on the number of directions in each shell. Each shell can have its own directions and number of directions. The minimum number of directions in a shell is dictated by the number of coefficients estimated, i.e. if lmax=4 => Num_of_coeff=15 => All shells should have at least 15 directions. This is because interpolation of the data occurs, when: i) different number of directions exist in different shells or ii) same number of directions, but corresponding directions between shells (e.g. dir1_shell1 vs dir1_shell2) differ more than 1 degree. In this case each shell is fitted with SH of the same order, which is by default 10, unless the number of directions in the shell with the less points is not enough (then order is decreased).</li>
<li>By default, same number of datapoints (including b=0's) are assumed for each shell acquisition. If this is not the case, a <i> --q=qshells.txt </i> file should be provided. The information in the qshells file is of the form <i> N1 N2 N3 </i>, each number indicating the number of datapoints (including b=0's) that correspond to each shell acquisition. 
</ul>